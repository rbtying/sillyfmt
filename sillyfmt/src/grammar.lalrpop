use crate::{
    Expr,
    dropped_tokens,
};

grammar;

pub Top: Box<Expr> = {
    <se: !*> <e: ExprSequence> => {
        if se.is_empty() {
            e
        } else {
            let mut s = vec![];
            s.extend(dropped_tokens(se));
            s.push(e);
            //s.extend(t);
            Box::new(Expr::Sequence(s))
        }
    },
}

Opening: Box<Expr> = {
    "," => Box::new(Expr::Item(<>.trim().to_string())),
    ":" => Box::new(Expr::Item(<>.trim().to_string())),
};

ExprSequence: Box<Expr> = {
    <e: Expr*> => Box::new(Expr::Sequence(<>)),
}

CommaSeqUnit: Box<Expr> = {
    ColonSeqUnit,
    ColonSequence,
};

ColonSeqUnit: Box<Expr> = {
    <u1: Item> <op: Symbol+> <u2: Item> => {
      let mut seq = vec![u1];
      seq.extend(op);
      seq.push(u2);
      Box::new(Expr::Sequence(seq))
    },
    Item,
    Container,
};

Expr: Box<Expr> = {
    CommaSequence,
    CommaSeqUnit,
};

Container: Box<Expr> = {
    "(" <e: ExprSequence> ")" => Box::new(Expr::Container('(', e, ')')),
    "[" <e: ExprSequence> "]" => Box::new(Expr::Container('[', e, ']')),
    "{" <e: ExprSequence> "}" => Box::new(Expr::Container('{', e, '}')),
    "(" <er: !+> <e: ExprSequence> ")" => {
        let mut seq = dropped_tokens(er);
        seq.push(e);
        Box::new(Expr::Container('(', Box::new(Expr::Sequence(seq)), ')'))
    },
    "[" <er: !+> <e: ExprSequence> "]" => {
        let mut seq = dropped_tokens(er);
        seq.push(e);
        Box::new(Expr::Container('[', Box::new(Expr::Sequence(seq)), ']'))
    },
    "{" <er: !+> <e: ExprSequence> "}" => {
        let mut seq = dropped_tokens(er);
        seq.push(e);
        Box::new(Expr::Container('{', Box::new(Expr::Sequence(seq)), '}'))
    },
};

Item: Box<Expr> = {
    r"[^()\[\]{},:=<>]+" => Box::new(Expr::Item(<>.trim().to_string())),
};

Symbol: Box<Expr> = {
    r"=>" => Box::new(Expr::Symbol(<>.trim().to_string())),
    r"->" => Box::new(Expr::Symbol(<>.trim().to_string())),
    r"<=" => Box::new(Expr::Symbol(<>.trim().to_string())),
    r">=" => Box::new(Expr::Symbol(<>.trim().to_string())),
    r"<=>" => Box::new(Expr::Symbol(<>.trim().to_string())),
    r"==" => Box::new(Expr::Symbol(<>.trim().to_string())),
    r"===" => Box::new(Expr::Symbol(<>.trim().to_string())),
    r"=" => Box::new(Expr::Symbol(<>.trim().to_string())),
    r"<" => Box::new(Expr::Symbol(<>.trim().to_string())),
    r">" => Box::new(Expr::Symbol(<>.trim().to_string())),
}

CommaSequence: Box<Expr> = {
    <s: CommaSeqUnit> <c: CommaPrefixed+> => Box::new(Expr::Sequence({
        let mut v = vec![s];
        v.extend(c.into_iter().map(|v| v.into_iter()).flatten());
        v
    })),
};

CommaPrefixed: Vec<Box<Expr>> = {
    <c: Comma+> <u: CommaSeqUnit> => {
        let mut c = c;
        c.push(u);
        c
    },
    <c: Comma+> <er: !+> => {
      let mut v = c;
      v.extend(dropped_tokens(er));
      v
    },
};

Comma: Box<Expr> = {
    "," => Box::new(Expr::Delimiter(',')),
};

ColonSequence: Box<Expr> = {
    <s: ColonSeqUnit> <c: ColonPrefixed+> => Box::new(Expr::Sequence({
        let mut v = vec![s];
        v.extend(c.into_iter().map(|v| v.into_iter()).flatten());
        v
    })),
    <s: ColonSeqUnit> <er: !+> => Box::new(Expr::Sequence({
        let mut v = vec![s];
        v.extend(dropped_tokens(er));
        v
    })),
};

ColonPrefixed: Vec<Box<Expr>> = {
    <c: Colon+> <u: ColonSeqUnit> => {
        let mut c = c;
        c.push(u);
        c
    },
    <c: Colon+> <er: !+> => {
      let mut v = c;
      v.extend(dropped_tokens(er));
      v
    },
};

Colon: Box<Expr> = {
    ":" => Box::new(Expr::Delimiter(':')),
};
